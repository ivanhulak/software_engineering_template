# Прототипний та об’єктно-орієнтований стиль програмування в js
___
## І. Прототипний стиль

__Прототипи. Шо це таке? Навіщо вони потрібні та як це працює у JavaScript?
Давайте розглянемо це на простому прикладі.__

Зараз я працюю в текстовому редакторі Sublime Text 3. Я створив два файли. Перший – це index.html, який просто підключає скріпт та другий файл index.js, який зараз пустий, але туди ми будемо записувати JavaScript код. Цей код в свою чергу буде виконуватися в браузері. Тому я відкрив свій html код в Chrome, увійшов в режим розробника та відкрив вкладення Console, для того щоб бачити результат виконання моєї програми, написаної на мові JavaScript.

<<<<<<< HEAD
![1.png]()

Коротка інструкція як відкрити консоль в браузері:
1. Знаходимо наш файл index.html 
2. Відкриваємо його в браузері
3. В правому вехньому куті натискаємо на три крапки (можливо у Вас по іншому)
4. Натискаємо на "Дополнительные инструменты" -> "Инструменты разработчика"
5. Далі переходимо у вкладення "Console"

Ось такий воно має виглядає у мене

![2.png]()
___
___Тепер давайте створимо якийсь об’єкт та пограємося з ним.___
За допомогою ключового слова const я створю новий об’єкт, який буде мати назву person (об'єкти в JavaScript створюються через фігурні дужки {} ). 
Нехай у цього об’єкта person буде декілька полів. Наприклад, поле `name` зі значенням `Maxim`; поле `age` зі значенням `25` та поле-функцію (в об’єктах також можна створювати функції), яка буде мати назву `greet` та виводитиме в консоль повідомлення `Greet!`.

```
const person = {
	name: 'Maxim',
	age: 25,
	greet: function(){
		console.log("Greet!")
	}
}
```

Добре, ми отримали деякий об'єкт. Тепер в браузері я оновлю сторінку, перейду в Console та напишу `person`. Ми побачимо ті поля, які ми задавали. Відповідно тепер ми можемо мати доступ до цих полів. 

![3.png]()

Якщо ми напишемо `person.name`, то ми отримаємо ім’я Максим, і так далі з полями `person.age` => `25` та `person.greet()` => `Greet!` Тут нібито все зрозуміло :)

![4.png]()
___

Тепер я очищу консоль та спробую зробити таку річ:
1. Я звернусь до свого об’єкта `person` та виведу у нього значення функції `sayHello()`
2. Я отримаю помилку, бо у об’єкта `person` немає такої функції як `sayHello`

![5.png]()

__В чому ж помилка!?__ Ми її (функцію `sayHello`) не визначили. Помилка досить логічна. Але ось в чому суть. Якщо я зараз знову звернусь до об’єкта `person` та викличу метод, який має назву `toString()`, то як видно ми не отримали вже ніякої помилки та при цьому в консолі ми отримуємо повідомлення ```[object Object]```, який є по суті рядком.

![6.png]()

_І автоматично формується запитання._ __Чому коли ми викликаємо функцію `sayHello()`, яку ми не визначали, ми отримуємо помилку, що є логічно, а коли викликаємо метод `toString()`, який ми також не визначали, то ніякої помилки немає?__ 

__Насправді, все дуже просто, бо саме так працюють ПРОТОТИПИ!__

>У об’єкта немає функції `sayHello()`. Ми отримали помилку, але у прототипа є функція `toString()` – ми отримали певне значення. Зараз можливо ще незрозуміло, але давайте напишемо наступне.

Напишемо просто `person` та `ENTER`
Тепер в консолі я можу розкрити даний об’єкт та побачити ті поля, які ми визначали, але окрім тих полів, які ми створювали, браузер нам показує деяку властивість як ```__proto__: Object```

![7.png]()

__```__proto__: Object``` – це спеціальна властивість, яка має посилання на прототип об’єкта, і там ми можемо бачити назву `Object`. Це назва деякого батьківського класу, який є батьком для цього об’єкта. Якщо ми розкриємо дану властивість, то тут ми побачимо велику кількість методів, де ми також побачимо той самий метод `toString`__

![8.png]()

>Тобто, коли ми викликали метод `toString()`, ми спочатку дивились на верхньому рівні даний об'єкт і якщо ми його не знаходили, то йшли в прототип і вже знаходили його там.

___
__Як це працює і взагалі навіщо ми взаємодіємо з ПРОТОТИПАМИ !?__

Давайте перепишемо нашу програму. Окрім того, що ми можемо створювати об’єкти через фігурні дужки {} , тобто насправді це просто деякий ярлик для спрощеного створення об’єктів. 
Але ми можемо переписати створення об’єкта `person` трохи інакше.   

Наприклад так:

```
const person = new Object({
	name: 'Maxim',
	age: 25,
	greet: function(){
		console.log("Greet!")
	}
})
```

Тобто зараз ми більш явно бачимо як відбувається створення об’єкта, а результат однаковий! 

![9.png]()

Тобто змінна ```person``` насправді є інстансом классу ```Object```. __І по суті, будь-які речі, які створюються в JavaScript є об’єктами!__ Зараз ми бачимо як ми створюємо змінну `person` від класу `Object` і тому, коли ми передаємо свої параметри, окрім цих параметрів нам в об’єкт потрапляє також прототип найголовнішого класу в JavaScript, тобто об’єкта(`Object`). А він в свою чергу несе свої поля, які ми можемо використовувати. Тобто насправді, ПРОТОТИП – це той самий об’єкт, який знаходиться у батьківських сутностей.

Тепер що ми можемо зробити? Ми можемо звернутися до глобального класу `Object`, а далі звернутися до його властивості під назвою `prototype`. І в цьому прототипі ми можемо створювати будь-які нові поля. Наприклад, я можу там створити функцію `sayHello()`. Це буде функція, де в консолі ми будемо виводити повідомлення `Hello!`

```
const person = new Object({
	name: 'Maxim',
	age: 25,
	greet: function(){
		console.log("Greet!")
	}
})

Object.prototype.sayHello = function(){
		console.log("Hello!")
}
```

![10.png]()

Отже, по суті, завдяки цій конструкції ми розширили базовий прототип класа `Object` та додали в нього новий метод (`sayHello()`). Після чого він став доступним для того об’єкта, який ми створюємо (в нашому випадку для об’єкта `person`)

І, насправді, прототипи так і працюють. Тобто, це деякий об’єкт, який присутній у батьківських елементах i за допомогою нього ми можемо успадковуватися від різних об’єктів та мати доступ до більш розширених функцій. 

___
Тепер для прикладу давайте розглянемо ще один момент.
Нехай я створю нову змінну під назвою `lena`. Далі я можу звернутися до глобального класу `Object`. У нього є метод під назвою `create`, за допомогою якого ми створюємо нові об’єкти. І далі в методі `create` ми можемо передати деякий об’єкт, який насправді буде прототипом для об’єкту `lena`. Наприклад, в якості прототипу я можу вказати об’єкт `person`, бо прототип – це об’єкт, а змінна ```person``` також є об’єктом.

```
const person = new Object({
	name: 'Maxim',
	age: 25,
	greet: function(){
		console.log("Greet!")
	}
})

Object.prototype.sayHello = function(){
		console.log("Hello!")
}

const lena = Object.create(person)
```

Тепер якщо я все збережу і подивлюсь у браузері, то я побачу, що `lena` – це пустий об'єкт. Якщо ми натиснемо на стрілку, ми нічого не побачимо на верхньому рівні, але у нього є прототип. Розкриваючи його, ми побачимо прототип того об'єкта від якого ми створювали, тобто в нашому випадку це об’єкт `person`. І далі у нас є ще нижній прототип, у якого є функція `sayHello()` чи, наприклад, функція `toString()`, яку ми викликали. 

![11.png]()

І по суті ми можемо робити з об’єктом `lena` що завгодно. Ми можемо написати `lena.name` та отримати `Maxim`. Знову ж таки, відкриваючи об’єкт `lena`, у нього немає на верхньому рівні ніяких полів, але якщо ми розкриємо прототип, то у нього є поле `name = Maxim`.

![12.png]()

Але це нелогічно і у об’єкта lena повинно бути своє ім’я.

```
const lena = Object.create(person)
lena.name = 'Elena'
```

Якщо я оновлю сторінку в браузері і напишу `lena`, я побачу, що тепер на верхньому рівні є поле `name`. 

![13.png]()

Якщо напишу `lena.name` то ми отримаємо ім’я `Elena`

![14.png]()

Але якщо я натисну на стрілку та розкрию прототип, то я побачу там поле `name`: `Maxim`. _Прототип як працює?_ Він працює зверху-вниз. Тобто якщо він на верхньому рівні знаходить деяку функцію, то він одразу ж її викликає, але якщо він нічого не знаходить, то тоді він звертається до прототипу і намагається знайти щось у ньому. Якщо ж він і там нічого не знаходить, то він далі рухається по ланцюгу прототипів і знаходить той метод, який він повинен викликати. Саме по цьому прикладу ми користуємося функцією `toString()`. Ну і якщо він нічого не знаходить в прототипі, тільки тоді він видає помилку. Це можна легко довести, визвавши функцію `sayHello()` у об’єкта `lena`. 

![15.png]()

>Хоча насправді ми знаємо, що ця функція знаходиться в прототипі прототипа даного об’єкта.

__Отже, насправді, це все, що стосується ПРОТОТИПІВ. Тобто ще раз! 
Це певний об’єкт, який присутній у об’єктів та він викликається по ланцюгу зверху-вниз.__

___

## Об’єктно-орієнтований стиль.





































































=======
![1](https://user-images.githubusercontent.com/71009515/116881623-26894180-ac2c-11eb-9644-a0edb34df1c4.png)
>>>>>>> 71763e4e3872601bb9b55796463eb1c0a4e7d224

