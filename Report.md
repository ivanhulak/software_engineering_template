# Прототипний та об’єктно-орієнтований стиль програмування в js
___
## І. Прототипний стиль

__Прототипи. Шо це таке? Навіщо вони потрібні та як це працює у JavaScript?
Давайте розглянемо це на простому прикладі.__

Зараз я працюю в текстовому редакторі Sublime Text 3. Я створив два файли. Перший – це index.html, який просто підключає скріпт та другий файл index.js, який зараз пустий, але туди ми будемо записувати JavaScript код. Цей код в свою чергу буде виконуватися в браузері. Тому я відкрив свій html код в Chrome, увійшов в режим розробника та відкрив вкладення Console, для того щоб бачити результат виконання моєї програми, написаної на мові JavaScript.

<<<<<<< HEAD
![1](https://user-images.githubusercontent.com/71009515/116895294-b7b3e480-ac3b-11eb-86fb-c934aa0c6e2e.png)

Коротка інструкція як відкрити консоль в браузері:
1. Знаходимо наш файл index.html 
2. Відкриваємо його в браузері
3. В правому вехньому куті натискаємо на три крапки (можливо у Вас по іншому)
4. Натискаємо на "Дополнительные инструменты" -> "Инструменты разработчика"
5. Далі переходимо у вкладення "Console"

Ось такий воно має виглядає у мене

![2](https://user-images.githubusercontent.com/71009515/116895348-c8fcf100-ac3b-11eb-859e-b0b0d21ce7fc.png)

___
___Тепер давайте створимо якийсь об’єкт та пограємося з ним.___
За допомогою ключового слова const я створю новий об’єкт, який буде мати назву person (об'єкти в JavaScript створюються через фігурні дужки {} ). 
Нехай у цього об’єкта person буде декілька полів. Наприклад, поле `name` зі значенням `Maxim`; поле `age` зі значенням `25` та поле-функцію (в об’єктах також можна створювати функції), яка буде мати назву `greet` та виводитиме в консоль повідомлення `Greet!`.

```
const person = {
	name: 'Maxim',
	age: 25,
	greet: function(){
		console.log("Greet!")
	}
}
```

Добре, ми отримали деякий об'єкт. Тепер в браузері я оновлю сторінку, перейду в Console та напишу `person`. Ми побачимо ті поля, які ми задавали. Відповідно тепер ми можемо мати доступ до цих полів. 

![3](https://user-images.githubusercontent.com/71009515/116895385-d2865900-ac3b-11eb-82f9-e6ee0096d876.png)

Якщо ми напишемо `person.name`, то ми отримаємо ім’я Максим, і так далі з полями `person.age` => `25` та `person.greet()` => `Greet!` Тут нібито все зрозуміло :)

![4](https://user-images.githubusercontent.com/71009515/116895399-d74b0d00-ac3b-11eb-979c-80889930eb60.png)
___

Тепер я очищу консоль та спробую зробити таку річ:
1. Я звернусь до свого об’єкта `person` та виведу у нього значення функції `sayHello()`
2. Я отримаю помилку, бо у об’єкта `person` немає такої функції як `sayHello`

![5](https://user-images.githubusercontent.com/71009515/116895412-db772a80-ac3b-11eb-8f5e-478720fd45e6.png)

__В чому ж помилка!?__ Ми її (функцію `sayHello`) не визначили. Помилка досить логічна. Але ось в чому суть. Якщо я зараз знову звернусь до об’єкта `person` та викличу метод, який має назву `toString()`, то як видно ми не отримали вже ніякої помилки та при цьому в консолі ми отримуємо повідомлення ```[object Object]```, який є по суті рядком.

![6](https://user-images.githubusercontent.com/71009515/116895430-e03bde80-ac3b-11eb-8f32-573dcb704512.png)

_І автоматично формується запитання._ __Чому коли ми викликаємо функцію `sayHello()`, яку ми не визначали, ми отримуємо помилку, що є логічно, а коли викликаємо метод `toString()`, який ми також не визначали, то ніякої помилки немає?__ 

__Насправді, все дуже просто, бо саме так працюють ПРОТОТИПИ!__

>У об’єкта немає функції `sayHello()`. Ми отримали помилку, але у прототипа є функція `toString()` – ми отримали певне значення. Зараз можливо ще незрозуміло, але давайте напишемо наступне.

Напишемо просто `person` та `ENTER`
Тепер в консолі я можу розкрити даний об’єкт та побачити ті поля, які ми визначали, але окрім тих полів, які ми створювали, браузер нам показує деяку властивість як ```__proto__: Object```

![7](https://user-images.githubusercontent.com/71009515/116895454-e6ca5600-ac3b-11eb-99fd-387bd3645ba2.png)

__```__proto__: Object``` – це спеціальна властивість, яка має посилання на прототип об’єкта, і там ми можемо бачити назву `Object`. Це назва деякого батьківського класу, який є батьком для цього об’єкта. Якщо ми розкриємо дану властивість, то тут ми побачимо велику кількість методів, де ми також побачимо той самий метод `toString`__

![8](https://user-images.githubusercontent.com/71009515/116895481-eaf67380-ac3b-11eb-9296-7c45aae1912d.png)

>Тобто, коли ми викликали метод `toString()`, ми спочатку дивились на верхньому рівні даний об'єкт і якщо ми його не знаходили, то йшли в прототип і вже знаходили його там.

___
__Як це працює і взагалі навіщо ми взаємодіємо з ПРОТОТИПАМИ !?__

Давайте перепишемо нашу програму. Окрім того, що ми можемо створювати об’єкти через фігурні дужки {} , тобто насправді це просто деякий ярлик для спрощеного створення об’єктів. 
Але ми можемо переписати створення об’єкта `person` трохи інакше.   

Наприклад так:

```
const person = new Object({
	name: 'Maxim',
	age: 25,
	greet: function(){
		console.log("Greet!")
	}
})
```

Тобто зараз ми більш явно бачимо як відбувається створення об’єкта, а результат однаковий! 

![9](https://user-images.githubusercontent.com/71009515/116895507-f2b61800-ac3b-11eb-9356-158da8faedb9.png)

Тобто змінна ```person``` насправді є інстансом классу ```Object```. __І по суті, будь-які речі, які створюються в JavaScript є об’єктами!__ Зараз ми бачимо як ми створюємо змінну `person` від класу `Object` і тому, коли ми передаємо свої параметри, окрім цих параметрів нам в об’єкт потрапляє також прототип найголовнішого класу в JavaScript, тобто об’єкта(`Object`). А він в свою чергу несе свої поля, які ми можемо використовувати. Тобто насправді, ПРОТОТИП – це той самий об’єкт, який знаходиться у батьківських сутностей.

Тепер що ми можемо зробити? Ми можемо звернутися до глобального класу `Object`, а далі звернутися до його властивості під назвою `prototype`. І в цьому прототипі ми можемо створювати будь-які нові поля. Наприклад, я можу там створити функцію `sayHello()`. Це буде функція, де в консолі ми будемо виводити повідомлення `Hello!`

```
const person = new Object({
	name: 'Maxim',
	age: 25,
	greet: function(){
		console.log("Greet!")
	}
})

Object.prototype.sayHello = function(){
		console.log("Hello!")
}
```

![10](https://user-images.githubusercontent.com/71009515/116895547-fea1da00-ac3b-11eb-8d44-c6793bdb8cd2.png)

Отже, по суті, завдяки цій конструкції ми розширили базовий прототип класа `Object` та додали в нього новий метод (`sayHello()`). Після чого він став доступним для того об’єкта, який ми створюємо (в нашому випадку для об’єкта `person`)

І, насправді, прототипи так і працюють. Тобто, це деякий об’єкт, який присутній у батьківських елементах i за допомогою нього ми можемо успадковуватися від різних об’єктів та мати доступ до більш розширених функцій. 

___
Тепер для прикладу давайте розглянемо ще один момент.
Нехай я створю нову змінну під назвою `lena`. Далі я можу звернутися до глобального класу `Object`. У нього є метод під назвою `create`, за допомогою якого ми створюємо нові об’єкти. І далі в методі `create` ми можемо передати деякий об’єкт, який насправді буде прототипом для об’єкту `lena`. Наприклад, в якості прототипу я можу вказати об’єкт `person`, бо прототип – це об’єкт, а змінна ```person``` також є об’єктом.

```
const person = new Object({
	name: 'Maxim',
	age: 25,
	greet: function(){
		console.log("Greet!")
	}
})

Object.prototype.sayHello = function(){
		console.log("Hello!")
}

const lena = Object.create(person)
```

Тепер якщо я все збережу і подивлюсь у браузері, то я побачу, що `lena` – це пустий об'єкт. Якщо ми натиснемо на стрілку, ми нічого не побачимо на верхньому рівні, але у нього є прототип. Розкриваючи його, ми побачимо прототип того об'єкта від якого ми створювали, тобто в нашому випадку це об’єкт `person`. І далі у нас є ще нижній прототип, у якого є функція `sayHello()` чи, наприклад, функція `toString()`, яку ми викликали. 

![11](https://user-images.githubusercontent.com/71009515/116895598-0b263280-ac3c-11eb-988a-2080f6ddd507.png)

І по суті ми можемо робити з об’єктом `lena` що завгодно. Ми можемо написати `lena.name` та отримати `Maxim`. Знову ж таки, відкриваючи об’єкт `lena`, у нього немає на верхньому рівні ніяких полів, але якщо ми розкриємо прототип, то у нього є поле `name = Maxim`.

![12](https://user-images.githubusercontent.com/71009515/116895621-10837d00-ac3c-11eb-80eb-25977adf7970.png)

Але це нелогічно і у об’єкта lena повинно бути своє ім’я.

```
const lena = Object.create(person)
lena.name = 'Elena'
```

Якщо я оновлю сторінку в браузері і напишу `lena`, я побачу, що тепер на верхньому рівні є поле `name`. 

![13](https://user-images.githubusercontent.com/71009515/116895644-15e0c780-ac3c-11eb-90f9-27146d04a5b5.png)

Якщо напишу `lena.name` то ми отримаємо ім’я `Elena`

![14](https://user-images.githubusercontent.com/71009515/116895669-1aa57b80-ac3c-11eb-88f4-eaf170a747a6.png)

Але якщо я натисну на стрілку та розкрию прототип, то я побачу там поле `name`: `Maxim`. _Прототип як працює?_ Він працює зверху-вниз. Тобто якщо він на верхньому рівні знаходить деяку функцію, то він одразу ж її викликає, але якщо він нічого не знаходить, то тоді він звертається до прототипу і намагається знайти щось у ньому. Якщо ж він і там нічого не знаходить, то він далі рухається по ланцюгу прототипів і знаходить той метод, який він повинен викликати. Саме по цьому прикладу ми користуємося функцією `toString()`. Ну і якщо він нічого не знаходить в прототипі, тільки тоді він видає помилку. Це можна легко довести, визвавши функцію `sayHello()` у об’єкта `lena`. 

![15](https://user-images.githubusercontent.com/71009515/116895685-2002c600-ac3c-11eb-89bb-2dc7ac336cfb.png)

>Хоча насправді ми знаємо, що ця функція знаходиться в прототипі прототипа даного об’єкта.

__Отже, насправді, це все, що стосується ПРОТОТИПІВ. Тобто ще раз! 
Це певний об’єкт, який присутній у об’єктів та він викликається по ланцюгу зверху-вниз.__

___

## Об’єктно-орієнтований стиль.

