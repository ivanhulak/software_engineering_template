# Прототипний та об’єктно-орієнтований стиль програмування в js
___
## І. Прототипний стиль

__Прототипи. Шо це таке? Навіщо вони потрібні та як це працює у JavaScript?
Давайте розглянемо це на простому прикладі.__

Зараз я працюю в текстовому редакторі Sublime Text 3. Я створив два файли. Перший – це index.html, який просто підключає скріпт та другий файл index.js, який зараз пустий, але туди ми будемо записувати JavaScript код. Цей код в свою чергу буде виконуватися в браузері. Тому я відкрив свій html код в Chrome, увійшов в режим розробника та відкрив вкладення Console, для того щоб бачити результат виконання моєї програми, написаної на мові JavaScript.

![1](https://user-images.githubusercontent.com/71009515/116895294-b7b3e480-ac3b-11eb-86fb-c934aa0c6e2e.png)

Коротка інструкція як відкрити консоль в браузері:
1. Знаходимо наш файл index.html 
2. Відкриваємо його в браузері
3. В правому вехньому куті натискаємо на три крапки (можливо у Вас по іншому)
4. Натискаємо на "Дополнительные инструменты" -> "Инструменты разработчика"
5. Далі переходимо у вкладення "Console"

Ось такий воно має виглядає у мене:

![2](https://user-images.githubusercontent.com/71009515/116895348-c8fcf100-ac3b-11eb-859e-b0b0d21ce7fc.png)

___
___Тепер давайте створимо якийсь об’єкт та пограємося з ним.___
За допомогою ключового слова const я створю новий об’єкт, який буде мати назву person (об'єкти в JavaScript створюються через фігурні дужки {} ). 
Нехай у цього об’єкта person буде декілька полів. Наприклад, поле `name` зі значенням `Maxim`; поле `age` зі значенням `25` та поле-функцію (в об’єктах також можна створювати функції), яка буде мати назву `greet` та виводитиме в консоль повідомлення `Greet!`.

```js
const person = {
	name: 'Maxim',
	age: 25,
	greet: function(){
		console.log("Greet!")
	}
}
```

Добре, ми отримали деякий об'єкт. Тепер в браузері я оновлю сторінку, перейду в Console та напишу `person`. Ми побачимо ті поля, які ми задавали. Відповідно тепер ми можемо мати доступ до цих полів. 

![3](https://user-images.githubusercontent.com/71009515/116895385-d2865900-ac3b-11eb-82f9-e6ee0096d876.png)

Якщо ми напишемо `person.name`, то ми отримаємо ім’я Максим, і так далі з полями `person.age` => `25` та `person.greet()` => `Greet!` Тут нібито все зрозуміло :)

![4](https://user-images.githubusercontent.com/71009515/116895399-d74b0d00-ac3b-11eb-979c-80889930eb60.png)
___

Тепер я очищу консоль та спробую зробити таку річ:
1. Я звернусь до свого об’єкта `person` та виведу у нього значення функції `sayHello()`
2. Я отримаю помилку, бо у об’єкта `person` немає такої функції як `sayHello`

![5](https://user-images.githubusercontent.com/71009515/116895412-db772a80-ac3b-11eb-8f5e-478720fd45e6.png)

__В чому ж помилка!?__ Ми її (функцію `sayHello`) не визначили. Помилка досить логічна. Але ось в чому суть. Якщо я зараз знову звернусь до об’єкта `person` та викличу метод, який має назву `toString()`, то як видно ми не отримали вже ніякої помилки та при цьому в консолі ми отримуємо повідомлення ```[object Object]```, який є по суті рядком.

![6](https://user-images.githubusercontent.com/71009515/116895430-e03bde80-ac3b-11eb-8f32-573dcb704512.png)

_І автоматично формується запитання._ __Чому коли ми викликаємо функцію `sayHello()`, яку ми не визначали, ми отримуємо помилку, що є логічно, а коли викликаємо метод `toString()`, який ми також не визначали, то ніякої помилки немає?__ 

__Насправді, все дуже просто, бо саме так працюють ПРОТОТИПИ!__

>У об’єкта немає функції `sayHello()`. Ми отримали помилку, але у прототипа є функція `toString()` – ми отримали певне значення. Зараз можливо ще незрозуміло, але давайте напишемо наступне.

Напишемо просто `person` та `ENTER`
Тепер в консолі я можу розкрити даний об’єкт та побачити ті поля, які ми визначали, але окрім тих полів, які ми створювали, браузер нам показує деяку властивість як ```__proto__: Object```

![7](https://user-images.githubusercontent.com/71009515/116895454-e6ca5600-ac3b-11eb-99fd-387bd3645ba2.png)

__```__proto__: Object``` – це спеціальна властивість, яка має посилання на прототип об’єкта, і там ми можемо бачити назву `Object`. Це назва деякого батьківського класу, який є батьком для цього об’єкта. Якщо ми розкриємо дану властивість, то тут ми побачимо велику кількість методів, де ми також побачимо той самий метод `toString`__

![8](https://user-images.githubusercontent.com/71009515/116895481-eaf67380-ac3b-11eb-9296-7c45aae1912d.png)

>Тобто, коли ми викликали метод `toString()`, ми спочатку дивились на верхньому рівні даний об'єкт і якщо ми його не знаходили, то йшли в прототип і вже знаходили його там.

___
__Як це працює і взагалі навіщо ми взаємодіємо з ПРОТОТИПАМИ !?__

Давайте перепишемо нашу програму. Окрім того, що ми можемо створювати об’єкти через фігурні дужки {} , тобто насправді це просто деякий ярлик для спрощеного створення об’єктів. 
Але ми можемо переписати створення об’єкта `person` трохи інакше.   

Наприклад так:

```js
const person = new Object({
	name: 'Maxim',
	age: 25,
	greet: function(){
		console.log("Greet!")
	}
})
```

Тобто зараз ми більш явно бачимо як відбувається створення об’єкта, а результат однаковий! 

![9](https://user-images.githubusercontent.com/71009515/116895507-f2b61800-ac3b-11eb-9356-158da8faedb9.png)

Тобто змінна ```person``` насправді є інстансом классу ```Object```. __І по суті, будь-які речі, які створюються в JavaScript є об’єктами!__ Зараз ми бачимо як ми створюємо змінну `person` від класу `Object` і тому, коли ми передаємо свої параметри, окрім цих параметрів нам в об’єкт потрапляє також прототип найголовнішого класу в JavaScript, тобто об’єкта(`Object`). А він в свою чергу несе свої поля, які ми можемо використовувати. Тобто насправді, ПРОТОТИП – це той самий об’єкт, який знаходиться у батьківських сутностей.

Тепер що ми можемо зробити? Ми можемо звернутися до глобального класу `Object`, а далі звернутися до його властивості під назвою `prototype`. І в цьому прототипі ми можемо створювати будь-які нові поля. Наприклад, я можу там створити функцію `sayHello()`. Це буде функція, де в консолі ми будемо виводити повідомлення `Hello!`

```js
const person = new Object({
	name: 'Maxim',
	age: 25,
	greet: function(){
		console.log("Greet!")
	}
})

Object.prototype.sayHello = function(){
		console.log("Hello!")
}
```

![10](https://user-images.githubusercontent.com/71009515/116895547-fea1da00-ac3b-11eb-8d44-c6793bdb8cd2.png)

Отже, по суті, завдяки цій конструкції ми розширили базовий прототип класа `Object` та додали в нього новий метод (`sayHello()`). Після чого він став доступним для того об’єкта, який ми створюємо (в нашому випадку для об’єкта `person`)

І, насправді, прототипи так і працюють. Тобто, це деякий об’єкт, який присутній у батьківських елементах i за допомогою нього ми можемо успадковуватися від різних об’єктів та мати доступ до більш розширених функцій. 

___
Тепер для прикладу давайте розглянемо ще один момент.
Нехай я створю нову змінну під назвою `lena`. Далі я можу звернутися до глобального класу `Object`. У нього є метод під назвою `create`, за допомогою якого ми створюємо нові об’єкти. І далі в методі `create` ми можемо передати деякий об’єкт, який насправді буде прототипом для об’єкту `lena`. Наприклад, в якості прототипу я можу вказати об’єкт `person`, бо прототип – це об’єкт, а змінна ```person``` також є об’єктом.

```js
const person = new Object({
	name: 'Maxim',
	age: 25,
	greet: function(){
		console.log("Greet!")
	}
})

Object.prototype.sayHello = function(){
		console.log("Hello!")
}

const lena = Object.create(person)
```

Тепер якщо я все збережу і подивлюсь у браузері, то я побачу, що `lena` – це пустий об'єкт. Якщо ми натиснемо на стрілку, ми нічого не побачимо на верхньому рівні, але у нього є прототип. Розкриваючи його, ми побачимо прототип того об'єкта від якого ми створювали, тобто в нашому випадку це об’єкт `person`. І далі у нас є ще нижній прототип, у якого є функція `sayHello()` чи, наприклад, функція `toString()`, яку ми викликали. 

![11](https://user-images.githubusercontent.com/71009515/116895598-0b263280-ac3c-11eb-988a-2080f6ddd507.png)

І по суті ми можемо робити з об’єктом `lena` що завгодно. Ми можемо написати `lena.name` та отримати `Maxim`. Знову ж таки, відкриваючи об’єкт `lena`, у нього немає на верхньому рівні ніяких полів, але якщо ми розкриємо прототип, то у нього є поле `name = Maxim`.

![12](https://user-images.githubusercontent.com/71009515/116895621-10837d00-ac3c-11eb-80eb-25977adf7970.png)

Але це нелогічно і у об’єкта lena повинно бути своє ім’я.

```js
const lena = Object.create(person)
lena.name = 'Elena'
```

Якщо я оновлю сторінку в браузері і напишу `lena`, я побачу, що тепер на верхньому рівні є поле `name`. 

![13](https://user-images.githubusercontent.com/71009515/116895644-15e0c780-ac3c-11eb-90f9-27146d04a5b5.png)

Якщо напишу `lena.name` то ми отримаємо ім’я `Elena`

![14](https://user-images.githubusercontent.com/71009515/116895669-1aa57b80-ac3c-11eb-88f4-eaf170a747a6.png)

Але якщо я натисну на стрілку та розкрию прототип, то я побачу там поле `name`: `Maxim`. _Прототип як працює?_ Він працює зверху-вниз. Тобто якщо він на верхньому рівні знаходить деяку функцію, то він одразу ж її викликає, але якщо він нічого не знаходить, то тоді він звертається до прототипу і намагається знайти щось у ньому. Якщо ж він і там нічого не знаходить, то він далі рухається по ланцюгу прототипів і знаходить той метод, який він повинен викликати. Саме по цьому прикладу ми користуємося функцією `toString()`. Ну і якщо він нічого не знаходить в прототипі, тільки тоді він видає помилку. Це можна легко довести, визвавши функцію `sayHello()` у об’єкта `lena`. 

![15](https://user-images.githubusercontent.com/71009515/116895685-2002c600-ac3c-11eb-89bb-2dc7ac336cfb.png)

>Хоча насправді ми знаємо, що ця функція знаходиться в прототипі прототипа даного об’єкта.

__Отже, насправді, це все, що стосується ПРОТОТИПІВ. Тобто ще раз! 
Це певний об’єкт, який присутній у об’єктів та він викликається по ланцюгу зверху-вниз.__

___

## II. Об’єктно-орієнтований стиль.

__Давайте розглянемо навіщо потрібні класи та що вони роблять.__ Для початку я створю звичайний об’єкт який має назву `animal`
Це буде звичайний об’єкт, у якого буде декілька полів (`name: ‘Animal’, age: 5, hasTail: true`)

```js
const animal = {
	name: "Animal",
	age: 5,
	hasTail: true
}
```

Якщо я зараз в консолі звернусь до об’єкта `animal`, то ми одержимо очікуваний результат. Тобто це звичайний об’єкт у якого є ті поля, які ми перерахували та прототип, який вказує на глобальний об’єкт `Object`. 

![16](https://user-images.githubusercontent.com/71009515/116905517-c30d0d00-ac47-11eb-9ae0-10a1459fdc5c.png)

Однак в дійсності, в JavaScript присутній спеціальний синтаксис класів, який дозволяє більш зручно та просто створювати подібні об’єкти. І давайте я покажу на цьому ж прикладі як це працює.

Спочатку, за допомогою ключового слова `class`, я створю клас `Аnimal` (класи називають з великої літери). Далі, в фігурних дужках ми описуємо цей клас. Для того щоб проініціалізувати початкові значення об’єкта даного класу потрібно реалізувати спеціальний метод під назвою `constructor`. І в конструктор ми будемо приймати деякий об’єкт `options`, який ми будемо перераховувати в наш клас. Для того щоб у нового інстанса класу `Аnimal` були ці поля, наприклад ми повинні їх проініціалізувати через ключове слово `this` (тобто контекст, який буде вказувати на поточний об’єкт). І тепер я перерахую, що `this.name = options.name` і так далі з іншими полями.

```js
class Animal {

	constructor (options){
		this.name = options.name
		this.age = options.age
		this.hasTail = options.hasTail
	}
}
```

__Тепер як нам створити той самий об’єкт `аnimal`, але вже за допомогою класу?__
Ми робимо практично теж саме, тобто ми створюємо об’єкт `аnimal` і далі за допомогою ключового слова `new` ми вказуємо від якого класу ми будемо його створювати (в нашому випадку це клас `Аnimal`) 

```js
const animal = new Animal()
```

А тепер в круглі дужки я буду передавати ті параметри, які я приймаю в конструкторі.

```js
class Animal {

	constructor (options){
		this.name = options.name
		this.age = options.age
		this.hasTail = options.hasTail
	}
}

const animal = new Animal({
	name: 'Animal',
	age: 5,
	hasTail: true
})
```

Далі, якщо я оновлю сторінку в браузері та звернусь в консоль до об’єкта `animal`, то я одержу тей самий результат, однак розумний Chrome нам показує, що даний об’єкт – не просто об’єкт, а він є нащадком класу `Аnimal`. І що доволі цікаво, що якщо ми подивимось в прототип, то в першу чергу ми не побачимо прототип об’єкта, а ми побачим прототип класу `Аnimal`, а вже потім прототип об’єкта.

![17](https://user-images.githubusercontent.com/71009515/116905533-c99b8480-ac47-11eb-8b72-ef58bd2297e3.png)

Відповідно, ми можемо в класі `Аnimal` реалізовувати деякі методи, які попадуть в прототип нашого майбутнього об’єкта. 
Тепер я тут реалізую метод `voice`, який буде в консолі виводити `I am an Animal`.

```js
voice (){
		console.log("I am an Animal")
	}
```

Якщо ми знову оновимо сторінку і звернемося до об’єкта `animal`, то як видно на скріншоті ми можемо визвати у нього метод `voice()`. Однак, якщо ми розгорнемо об'єкт `animal`, то у нього не буде методу `voice()` на верхньому рівні, але він є у прототипі. 

![18](https://user-images.githubusercontent.com/71009515/116905545-cd2f0b80-ac47-11eb-84cc-deb0348167d8.png)

![19](https://user-images.githubusercontent.com/71009515/116905564-d324ec80-ac47-11eb-899a-9bb2f608bc95.png)

__Що ж ще ми можемо робити з класами?__ Ми можемо використовувати статичні методи чи змінні за допомогою ключового слова `static`. 
Я заведу змінну `type`, яка буде містити в собі рядок `ANIMAL`. 

```static type = 'ANIMAL'```

__Як тепер цим користуватися?__ Якщо я спробую в консолі звернутися до об’єкта `animal` та спробую написати `type`, то в дійсності я побачу `undefined`.

![20](https://user-images.githubusercontent.com/71009515/116905581-d91acd80-ac47-11eb-8981-fa21e332d269.png)

Як же тепер нам звернутися до цього типу? Якщо змінна чи метод є статичним, тоді вона доступна тільки в класі. Тоді слід звертатися вже з великої літери (до класу). 

![21](https://user-images.githubusercontent.com/71009515/116905597-df10ae80-ac47-11eb-84ec-bf06699e0ac6.png)

___
Тепер, давайте розбереме наступний момент, а саме чому класи можуть бути зручними. (Я закоментую створення об’єкта та створю новий клас `Cat`)

Клас `Cat` буде деяким окремим випадком і для того щоб мені успадкуватися від класу `Аnimal` я використаю ключове слова `extends`.
А далі створю новий об’єкт `cat`, який приймає ті ж самі параметри в конструктор. 


```js
class Cat extends Animal {}

const cat = new Cat({
	name: 'Cat',
	age: 7,
	hasTail: true
})
```

Якщо я зараз звернусь до об’єкта `cat` в консолі, то ми побачимо наступне:

![22](https://user-images.githubusercontent.com/71009515/116905611-e46df900-ac47-11eb-88c0-61d6171aa44d.png)

Це просто звичайний об’єкт (ми можемо звертатися до його полів). Однак браузер вже показує нам, що об’єкт `cat` належить класу `Cat`. І якщо ми подивимось на прототип, то спочатку ми побачим клас `Cat`, потім ми побачим клас `Animal` і тільки в останню чергу `Object`.

Ми можемо звертатися до методу `voice()`, адже він визначений в батьківському класі. 

![23](https://user-images.githubusercontent.com/71009515/116905626-e89a1680-ac47-11eb-8a42-c79c76fda676.png)

В класі `Cat` ми також можемо заводити статичні поля. Та звертатися до них в консолі.

```js
class Cat extends Animal {
	
	static type = 'CAT'
}
```

![24](https://user-images.githubusercontent.com/71009515/116905640-ecc63400-ac47-11eb-981d-16ec948683f4.png)

Але що нам робити, якщо для класа `Cat` ми також хочемо передавати додаткові параметри (наприклад колір тварини). І ми також хочемо передавати його в конструтор. Тоді для цього ми реалізовуємо конструктор, але вже в класі `Cat`.

```js
class Cat extends Animal {
	
	static type = 'CAT'

	constructor(options){
		this.colour = options.colour
	}
}
```

__Але якщо я напишу так як на скріншоті, то я отримаю помилку.__

![25](https://user-images.githubusercontent.com/71009515/116905649-f059bb00-ac47-11eb-9097-0914d1c623b4.png)

Це все пов'язано з тим, що коли ми реалізуємо метод-конструктор в дочірньому класі, який успадковується від іншого класу, ми для початку повинні викликати батьківський конструктор. І для цього присутнє спеціальне ключове слово під назвою `super()`, яке по факту є методом. Але слід не забути передати в метод `super` параметр `options`.

![26](https://user-images.githubusercontent.com/71009515/116905660-f3ed4200-ac47-11eb-84ad-61d794351a20.png)

Тепер якщо оновити сторінку в браузері у нашого об’єкту `cat` буде додано нове поле `colour` зі значенням `black`w.

![27](https://user-images.githubusercontent.com/71009515/116905673-f6e83280-ac47-11eb-9593-5f7570f41943.png)

Що є досить цікавим, так це те, що в класі `Cat` ми можемо переписувати батьківські методи. Наприклад, в класі `Animal` у нас реалізований метод `voice`. Ми можемо його переписати.

![28](https://user-images.githubusercontent.com/71009515/116905684-f9e32300-ac47-11eb-8023-62ac20d597f3.png)

Тобто якщо у дочірньому класі реалізований будь-який метод, то він перетинає батьківський. Але бувають випадки коли нам потрібно викликати батьківські методи. В цьому ж випадку на допомогу приходить метод `super()``

```js
class Cat extends Animal {
	
	static type = 'CAT'

	constructor(options){
		super(options)
		this.colour = options.colour
	}

	voice(){
		super.voice()
		console.log("I am a cat")
	}
}

const cat = new Cat({
	name: 'Cat',
	age: 7,
	hasTail: true,
	colour: "black"
})
```

![29](https://user-images.githubusercontent.com/71009515/116905694-fe0f4080-ac47-11eb-87cf-238eb32e26f9.png)

Спочатку ми отримуємо `I am an Animal` - це батьківський метод, а тільки потім `I am a cat` - тобто визивається наш метод. 

___
__Також в класах присутні такі поняття як `get` та `set` ("Гетери та Сетери"). Реалізовуються вони за допомогою ключових слів `get` та `set` відповідно.__

Припустимо, що ми хочемо показувати справжній вік тварини. (Я не знаю яка система числення віку у тварин, тому все буду робити як для людей). Далі допишу наступний код в клас `Cat`

```js
get ageInfo(){
	return this.age
}
```

Ось такий результат ми отримаємо в консолі, якщо звернемося до нашого поля `ageInfo`. 

![30](https://user-images.githubusercontent.com/71009515/116905708-02d3f480-ac48-11eb-8a97-2a99efddbb84.png)

Якщо ми подивимось у консоль, що ж таке гетер, то браузер покаже нам його в такому вигляді: 

![31](https://user-images.githubusercontent.com/71009515/116905716-06677b80-ac48-11eb-85a6-310fa48fdeb2.png)

Якщо натиснути на три крапки, то побачимо результат. __Саме так працюють гетери.__

![32](https://user-images.githubusercontent.com/71009515/116905727-09626c00-ac48-11eb-811d-2deaac42bf68.png)
___

Аналогічно, ми можемо робити будь-які сетери. Я реалізую сетер `ageInfo`, в якому буду змінювати вік тварини. Тобто я буду змінювати конкретне поле в самому об’єкті.
Ось такі рядки коду я дописав в клас `Cat`. 

```js
set ageInfo(newAge){
	this.age = newAge
}
```

Тепер переходимо в консоль браузера. Якщо я звернусь до об’єкта `cat`, а саме до його поля `ageInfo` та призначу цьому полю нове значення, то отримаю наступний результат.

![33](https://user-images.githubusercontent.com/71009515/116905742-0d8e8980-ac48-11eb-9058-3a9fbcf1646d.png)

Покроково що я зробив:
1. На першому кроці я змінив вік тварини. (як сетер)
2. На другому кроці я звернувся до поля `ageInfo` (як гетер) 
3. На третьому кроці я перевірив чи змінився вік тварини в об’єкті. 
Тобто в сетері я змінив поле `this.age`, а в гетері я до нього звернувся.

__Ось так працюють гетери та сетери.__

___

__Насправді це все, що стосується класів. Тут немає нічого складного! І взагалі класи – це просто зручний синтаксис для створення об’єктів. Ми можем дуже круто вносити певну логіку в базові класи, зручно цим користуватися, задавати на певних етапах будь-які методи в прототипі та працювати з ними.__

___

Матеріал підготував: студент групи ІВ-93 [Гулак Іван](https://github.com/ivanhulak)..
___
Вихідні файли проектів:

https://github.com/ivanhulak/software_engineering_template
